<!DOCTYPE html>
<html>
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-108813396-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-108813396-1');
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../static/css/style.css">
    <title>How to Join a New Team and Learn a New Codebase - Samuel Taylor</title>
  </head>
  <body>
<span class="breadcrumb"><a href="../index.html">Home</a> &gt; <a href="index.html">Articles</a> &gt; How to Join a New Team and Learn a New Codebase</span>
<h1>How to Join a New Team and Learn a New Codebase</h1>
<p>Alternate title: <em>new codebase who dis?</em></p>
<p>Delivered at:</p>
<ul>
<li><a rel="nofollow" href="https://www.southerndevfest.com/speakers#h.dv39kanwh16k">Southern DevFest 2020</a>. Slides available <a rel="nofollow" href="/static/pdf/ncwd_sdf20.pdf">here</a>.</li>
</ul>
<p>Find me on Twitter <a rel="nofollow" href="https://twitter.com/SamuelDataT">@SamuelDataT</a>.</p>
<h2>Transcript</h2>
<p><em>Note: This transcript is from an early practice run and will be updated.</em></p>
<p>0:13<br />
Working in the software industry is like this pizza. Stay with me. When I went to school I was looking at but pizza of software in sort of a small way, I could only see through this little window that I had from what I could see in school. And I saw all these pepperonis on the pizza, I saw, bouncing abl trees, I saw implementing quadratic probing, I saw, like really cool search algorithms. I'm like, oh, man, this is gonna be so cool. I'm gonna be implementing all these dope algorithms all the time. And then what happened was, right, I, I bought the pizza, I opened up the thing, you know, I got a job, and realized, it's not all it's not all that. There is certainly some of that. But there is a lot of the pizza that is fighting with Iam permissions, or figuring out why your build is failing. One of the biggest things that I didn't really know how to do, coming straight out of school that I sort of had to teach myself was figuring out how to learn a new codebase. You know, I joined a company and started working there and didn't really immediately grasp how to read the code and be productive on day one. So this is the talk that I wish I had seen at some point before I graduated. So that way, I could be more productive, and save myself a lot of time. Here is the rough way, we're going to walk through that today, you will probably notice that we're currently in the introduction, we're going to talk about just some tips I have for joining a new team in general. On day one, we will then talk a little bit about the mindset sort of a way to think about this, before you progress onto a recommended process that I have and have been following and really like. Finally, we will talk about some tools that can make all of this a lot easier. So on day one, I think there's three things you should try to do when you join a new team. And whether that's a new team, at the company you're already at, or whether you are joining a completely new company, these steps more or less hold. The first thing that you want to do when you are setting up your development environment is make sure you're paying attention to what's going on. For instance, you need to know what services you're running. Like if you suddenly are running Redis on your laptop, then you might note you might think to yourself, oh, hey, I'm running Redis that maybe means that we are caching something, you know, sort of put that in the back of your mind and understand it. You could also understand what dependencies exist between services. So knowing about, you know, I have to have service a running before I have service B running, that might tell me that service B probably uses service a. And then another thing that I want to mention is to take specific notes as you are setting up your environment. Because you'll you'll want to write down like what commands are you running, that will be really helpful, because I think everyone here</p>
<p>3:19<br />
has probably</p>
<p>3:21<br />
because I think that everyone here has probably screwed up your Python installation. Good to know exactly how you did that for later.</p>
<p>3:29<br />
Another thing that you should definitely do on day one</p>
<p>3:32<br />
is if you can get the test suite running, that is usually half the battle. And you want to make sure that you can see all the tests go green, and then just like literally pick a random file and like delete some lines and see what breaks like obviously, you'll probably get some compiler errors. And if you're not using a compiled language, maybe you don't maybe some tests fail. And you can start to see like, where that is and what breaking stuff has, what effect breaking stuff has on the various tests.</p>
<p>4:02<br />
The next thing,</p>
<p>4:03<br />
step two, you should start to get an understanding of the architecture that you're going to be working. And ideally, there is some sort of document or a diagram like on a wiki page or something.</p>
<p>4:16<br />
If you do find one of these</p>
<p>4:18<br />
try to understand when it was created because sometimes in certain places, these documents go out of date really quickly. And you want to make sure that you're not learning something that is completely inaccurate. I highly recommend, ask a lot of questions, talk to people, even questions that you know you're worried might be dumb. You need to embrace looking like a complete idiot if it enables you to learn something. And a good healthy team will support that. Some great questions to start asking include like what repos are we in charge of when I have something working on my laptop? What are the steps to get that into production that seems to vary everywhere just slightly. Knowing about certain vendors that we use or API's that we're using is also helpful stuff to start to get a picture of, sort of what's going on. It's a super helpful thing you can do for the whole team. You know, initially, when you start, you might not be the most productive. So it's good to have an easy win up front. And one easy way you can have is to update that document if it already existed, or to create one if it didn't exist. And that can be something as simple as just like literally a piece of paper that you're drawing some shapes on, and writing some words on, it doesn't have to be complicated. Just get an understanding of what the architecture looks like and try to communicate it on a piece of paper is going to be a really nice helpful thing to your team and to future members of your team. The third thing that you should start doing on day one, when you join a new team is to understand the business, you are completely doomed. If you don't understand what's going on, you need to understand the mission of the company and the products that you offer. And the goals that the team has. Are there certain goal setting frameworks for us, are there like what are our goals? And what are the ways we can achieve those goals, that kind of thing. You want understand how your team fits into the mission of the company. And that way you can start to gain context on the stuff you'll be working on. If you don't understand the context of why it matters that for instance, you're able to show high scores on some certain page, you probably won't be thinking about the you probably won't be thinking clearly about what kind of information should show up on that page, and will generally just be less effective. Some great questions to ask here are things like, hey, how can we impact the goals</p>
<p>6:40<br />
of the company? What's the biggest thing we could do there?</p>
<p>6:43<br />
If our code just like completely</p>
<p>6:45<br />
breaks it? Is someone gonna get mad? And if they do, who is that person? How long? Is it going to take them to notice? Those kinds of things are good to know. Ideally, on day one, you are not breaking production. But it's happened before. And if that does happen, you want to know exactly how screwed you would be. All right. Well, let's now talk</p>
<p>7:04<br />
about the mindset.</p>
<p>7:06<br />
And as I haven't a little subtitle here, the general thought</p>
<p>7:10<br />
process can sort of be summarized as learn by doing.</p>
<p>7:14<br />
There's a book I really like called ultra learning</p>
<p>7:16<br />
by Scott young, who is like sort of an autodidactic character, and has a lot of recommendations about how you should learn stuff. It's a really fascinating read, if you're just interested in learning and this particular in teaching yourself something very quickly. It's a really interesting book. One of the things that he particularly recommends is this idea of</p>
<p>7:36<br />
directness.</p>
<p>7:38<br />
And he says that the easiest way to learn directly is to simply spend a lot of time and doing the thing you want to become good at. That is exactly what we should be optimizing for when we are learning a new codebase the whole point, the whole thing of being a software engineer, is going to be, you know, implementing features that help the business achieve its outcomes. And there is no better way</p>
<p>8:02<br />
to do that,</p>
<p>8:02<br />
there's no better way to learn how to do that than to just jump in, do it.</p>
<p>8:07<br />
So you should start to get</p>
<p>8:09<br />
tickets like find, ideally, your team has queued up some sort of simpler or easier tickets that you can get started with to sort of get your feet wet. But really the goal like you're gonna learn best by just jumping in and going for it, you don't need to spend a bunch of time reading the code, trying to understand every little nitpicky detail, just jump in and get started. You probably know this if you've done any coding at all. But reading a book is very different from reading code. Imagine if, instead of the Lord of the Rings trilogy that we have, it was like, you know, 20 volumes and Volume One was just all of the sword fighting. And Volume Two was all of the food scenes. And volume three was all the scenes that had magic in it. But also, actually volume six has some of the magic scenes in it, but not all of them. And actually, you know, you could imagine that these books would not</p>
<p>9:01<br />
be very fun to read.</p>
<p>9:02<br />
And in fact, they would not be.</p>
<p>9:04<br />
But that is basically how code is organized. You know, we don't have it set up for a nice clean narrative for someone to you know, start at the beginning and go to the end. There is not one file generally. And there's going to be multiple files that you're going to need to understand how they relate to each other. And that is just a incredibly different way of thinking about reading than reading a book, you're going to you will gain a deep understanding by making impact. What you do want to do, my general rule of thumb is as I'm sort of working in a new codebase I want to understand the things that I'm working on well enough to understand what it is they do without necessarily understanding how they do it. So I might know that this service sends emails, but I don't need to know like it uses sendgrid and blah, blah blah like nope, it just it sends emails. That's all you need to know about for now. What you don't need to do go through and read every dang line,</p>
<p>10:02<br />
you are going to have a really bad time if you try to do that.</p>
<p>10:05<br />
And I would caution you against doing that you</p>
<p>10:10<br />
you need to sort of work to</p>
<p>10:15<br />
you need to sort of work to read a book different reading code, bla bla bla bla bla bla bla.</p>
<p>10:48<br />
So as you're reading, you'll find that your knowledge sort of grows recursively. So what I mean by that is, at the start, you'll just be asking, you know, a senior member of the team, hey, what services do we maintain? What do they more or less do? And so you might find that like, this one, stores all of our high scores, and this one sends emails and this and blah, blah, right? different bits of our codebase do different things, different different things to different things. And then you might not think about like, Okay, well, I need to add, I need to fix this bug that's related to the top score, not showing it so good. Well, that's probably in the high score service. And so you go in there, and then you start to read all the different modules in here, like, Are there different? Like, how is the code structured in here? What's the organization pattern, and then you're going to figure out what modules you need to use. And inside that, you're going to start to understand what classes are there,</p>
<p>11:36<br />
etc, etc, etc, in debt until down at a certain</p>
<p>11:38<br />
point, you're going to be reading individual lines of code. And that is sort of the most base level. And I think once we get to that level of understanding that individual line, things are generally good if you understand how to program, obviously, but as he sort of walked back up, that's the part that I found really hard was understanding like, Okay, what bits of this code? Do I understand well, and what do I not? And what things do I need to understand well, versus don't need to understand. So this sort of recursive knowledge process is basically chunking.</p>
<p>12:09<br />
chunking is a term that neuroscientists use to</p>
<p>12:12<br />
describe the way that the brain binds detailed information into some easy to remember concept. So for instance, you might one day be working on the email service and find out, okay, our email service, when we call send email, it's going to validate the contents in that it's going to check against our do not, you know, do not email list. And then finally is going to make an API call to sendgrid. So there's three steps here. But what you what your brain can do is chunk those three steps into Oh, that's the thing that sends email. Okay. And when you have that easy to remember concept in your head, that's going to make things so much easier for you. The last bit of advice I have is to think in terms of code pads and data flows. I have sometimes found it useful to just draw myself little diagrams that look something like this. So if I had puppies API, which, man would that be nice in 2020? I have a way to just get a puppy. That'd be amazing. Just give me Show me a puppy. That'd be awesome. I would love it anyway. So one, one thing you might start to think about is, okay, when someone goes to slash puppy, what happens, okay, they go to slash puppy, it calls this, you know, function get Puppy in my, in my Python file, and then that goes to my, you know, intern has a puppy manager that will get a random puppy,</p>
<p>13:27<br />
which in turn,</p>
<p>13:29<br />
uses this database access class to run some query that picks out a, you know, a puppy for me to see. And sort of think about understanding these code paths. And exactly where am I coming from? And where am I going to, it's very useful. You can also think about this in terms of data flows, and understanding what objects know what information at what time. So every instance, we might think about, okay, our scores are stored in the database, then the score Tao is the thing that sort of pulls data in from the scores database, and then the score controller only has information about the score dow, and then scoreboard, j s, might, you know, in turn call to something that is inside of score control. So the data flows from the database, through this through these few objects out to, you know, a JavaScript client, basically, these are two ways that I have found useful to think about the organization of code.</p>
<p>14:19<br />
So all of this,</p>
<p>14:22<br />
let us now talk about process. And like with the last section, I have a brief summary at the start. The gist is that I think the scientific method is one of the greatest achievements of humanity. And I think it would be, we would be remiss to not observe the insight that this product that the scientific method has for us and use it to help us. Right, write code better and understand code better. So I kind of identify roughly four steps depending on how you count. So the first thing that you'll want to do is find out what code is irrelevant. So for instance, if I'm trying to do something with the scoring service, you know, I'm trying to do something related to scores, I know it's going to be in the scoring service probably. Okay. And I don't need to worry about the email service, because it's not, it's not relevant, right. So I need to understand what code is relevant. That's step one. And then I need to form a hypothesis about what I need to change. So this is going to require us understanding the is it going to require an understanding the, the service that we're working on the code the Oregon well enough to know what I need to change, and that's going to, you know, go back to this recursive knowledge growth process that we'll talk about more. But once you have your hypothesis about what you need to change, so you might think to yourself, okay, in the high score controller, I think there's an off by one error. So I'm going to change that. And I expect to see a, you know, the bug be fixed. So the next step is to test your hypothesis. So you'll want to go ahead and make that change. And then understand if you were correct or not, there are some people who are big fans of test driven development. And I think it's, it can be super useful. So one way that you can implement the steps two and three is to actually like, you know, write the test that says, okay, call this thing, call this controller, make sure that I get six results in it, rather than five, something like that, and then make the change, and run the test. That's a really nifty, I think, developer experience. But you don't have to do that you can also just make the change and do the call in your web browser or whatever. And that could be really useful. If you are wrong, if you change the thing, and the bug is still there, for instance, then you're gonna need to go back to to understand what you did wrong, and understand how you might make a change. And so this is sort of the iterative thing here is like, understand the code better, and then try to make a change. And keep doing that until you get to a solution. Once you're done, you're not done. Okay, so step four is to improve the quality of that. So once you have working code, at least for me, I don't know about anyone else, I do not write perfect code on the very first try. So it's really useful at this point to, if you didn't write a test before, make sure you're writing a test now. Or if there are ways that you can refactor your code to have it be more legible, more maintainable for future you or for future teammates, they should definitely do that. That is a crucial, crucial part of the step, just getting the problem solved is often not enough. Code is read far more often than it is written and it would be stupid to not optimize for the reading process. Alright, this is the last bit here and talk about tools that we can use to make this all happen.</p>
<p>17:58<br />
So there are,</p>
<p>18:00<br />
you know, basically, we're going to talk about tools that you can use to help you in each of these various steps. So first, we'll talk about that first step, which is finding relevant code. And the first sort of thing to do is run the code. So this will help you understand what exists if you can, you know, get the service running, and navigate to the page that displays your high scores, you can understand Oh, well, on this page, we don't even list high scores, or on this page, we do list out like usernames, and now we want to add a date or something. And understanding the landscape that you're about to be going into can be super helpful, and I highly recommend it. The other thing I would recommend doing is to use the debugger, it is a very crucial and helpful piece of of, of equipment, essentially. And that I don't think gets enough credit. It's called the debugger, but you don't have to just use it for finding bugs, you can just run the program that is working perfectly fine. And just keep stepping and seeing what code is running and help you and that will help you in a major way. Understand what is going on. So you can see exactly what's happening. It's like okay, well, this, you know, we're jumping into this function suddenly, and now we are going off to the database and getting out some puppy from it, right? That is a super useful tool, and I highly recommend it. And also, when you're trying to find relevant code, I would recommend searching the project. So if you buy project here, I mean, sort of things like in JIRA, Asana, GitHub issues, that kind of thing. If you go to JIRA, and you're working on something with date times, you could type in date time, and you'll get this big list of issues that that are, you know, have the word date time in them, and you can look through them and try to understand, has someone done something similar to this before? Is there anything I can use more any information that they shared about this? That'll be super useful information. Remember, it is pretty challenging in my opinion. To create really good software, and the less work you can do, the better. The best engineer is a lazy engineer. And one great way to be lazy is to just use existing stuff. This is another way in which I think school is not always the greatest, where if I were to, you know, copy an essay in school, that would be bad. But if I were to use an appropriately licensed piece of open source software, that's amazing, that's super good, because it means I didn't have to do a bunch of work, and I got the value. So similarly, you can benefit from the work of your colleagues and understand what has already been done and build on top of that. And this is just another screenshot to show you sort of what the the GitHub issues UI looks like. So you can see things like, here's some, you know, something that someone is talking about, and read through the discussion about it. And you can get a better understanding of what's going on in this project, even if you don't really know a whole lot about it, just by reading through these kinds of things. And this can be a real help. Okay, if you. Yeah, so another another way that you can start to find relevant code is just searching it directly. There's a bunch of different tools, like obviously grep exists on the on the command line. But there are tools that are sort of made specifically for searching large amounts of files and our work really well. In programming context. The one that I generally use is called silver searcher. Rip grep is a recent, or I guess it's not really all that recent. But rip grep is is another tool that is very similar, but I have not personally use but I've heard great things about this is just a little screenshot, show you what it does, I went to my terminal, and I typed in ag space phony, and it found me all the places in my code where the word phoneme was used. And so I can look at it and see, okay, the source slash app.pi, is doing something with phonemes. And then I see some, you know, information about phoneme in this file called CMU dict. And that helps me know, if I'm doing something with phonemes, these are good places to look. So I found some code that's relevant to the topic of phonemes. Now, these are great tools, if you have the code locally checked out locally, but in a lot of cases, it's difficult to have all of the code locally on your machine.</p>
<p>22:25<br />
Often, oftentimes, companies, you'll find situations where the total amount of code at the company is very large, it would just be a paid to have all of it on your laptop. So this will vary from company to company. And you should just like do, like use whatever tools your company is using. But if just for your benefit, some common tools are things like open grok, or source graph. This is kind of what open grok looks like. It gives you this little web UI where you can go to and type in a search and try to find so for instance, this this person, this person post, in this screenshot is looking for files or is looking for definitions that have util and the name. So there, you can see file util on form util and GUI resource utiliser are the search results that came back for that. This can be another really great way to find relevant code, particularly if you're worried about like breaking something for large amounts of people, you can understand, hey, who all is using this service call that I'm making that kind of thing. Another way you can be really useful is to find someone else who has already done something similar to you. I said earlier, and I strongly stand by the concept that you should as much as possible crib from your teammates, because they probably did a good job, I hope. And you can save yourself a lot of heartache that way, by finding some some working piece of software and then modifying it to do what you want it to do. So yeah, open grok is a great bit of tool as a great tool. And then GitHub and get lab also have like organizations and you can search within your organization. And that's another common way that I've seen people do this. So for understanding code, the first thing I want to point out is using your IDE. I am completely not affiliated with JetBrains. But I really like their IDs. And I know there's there's similar functionality in other tools. But JetBrains is the thing that I know best. So that's the thing that I'm going to show you. There's a function where you can sort of hold down command on a Mac and click on it. And it will take you to the definition of the function. And so that's sort of what I'm showing you in this little video here. If I'm trying to understand what is this word to phonemes thing, or what is this leftist thing, I can click on it, and it'll take me right to it. And then once I'm there, if I hold down Command and click on it, it'll show me usages of that. So again, for here, I you know, I clicked there and it shows me that this is the definition of word phonemes. And then when I'm at word to phonemes, if to click on it again, it will show you, here's the people or here's the places that word to phonemes is being used.</p>
<p>25:07<br />
Again, this is super useful, you can see,</p>
<p>25:10<br />
very quickly, what is the definition of this thing. So if I'm trying to understand, like, what is word to phonemes, I think maybe this is the thing that you need to modify, I can Command click and go right to it. And start to get that understanding by reading the code, specifically, the sort of inverse, where you're trying to find usages of the thing is also super useful, because for instance, if you're trying to use some objects that you're not super familiar with, if you can click it, and it'll take you to the definition, and then you can come and click it again, it will show you other people who are using it. And that can be really helpful to see Oh, well, you know, my coworker Joe, has done this this way. And I see, you know, this is the sort of API for this object, and I now know what to do, which is really useful. Okay, so you can use your ID, I will say, you should also, as you're doing this, as you're trying to understand the code, remember to be creating these chunks in your brain. You want to not necessarily need to know all of the details of every single interaction, you want to be able to create these chumps that say, Okay, well, now we're going to take the word and turn it into phonemes, you don't need to know, I'm going to look this up in the dictionary, blah, blah, blah, you just need to know this turns a word into phonemes.</p>
<p>26:31<br />
And then, finally,</p>
<p>26:35<br />
I have found it useful to make notes for myself or draw little diagrams. This can be things like writing down file names, and what you think it's doing or writing down questions as you have them going through and trying to actually write down like, Hey, I was working, I'm working in this part of the code, I'm trying to understand this problem. And can really, at least from my, my experience, can help me stay on task and help me be better at getting interrupted. But also just help me understand what's going on better. Sometimes, it's difficult to keep everything all in your brain, it's useful to get out somewhere else, since that can be a piece of paper, that can be a notetaking, app, whatever you like. And it doesn't need to be complicated. And you can just draw a little diagram for yourself, say this, you know, this class calls, this one calls this one etc, it can be really quick and useful to do that. And I also want to say that this does not necessarily come natural to me. But something that I have definitely learned in thus far is that asking for help is not a bad thing to do. It's not a sign of weakness. In a healthy team, you should find that your coworkers are being really helpful, and they want to help you succeed. And one specific tool that you can use to figure out who do I need to ask is get blamed. So for instance, here I run, get blame on a piece of a library that I use. And I can see over on the left side, that first column is the git commit hash, which can be useful, you can sort of understand what changes were made. And when they're made. That second column is the name or author of that certain line that the person who modified that line most recently, then you see the date of the modification? And then lastly, you see the the line number, before you see the actual code. And so if you're wondering, like, what is this get var type thing, I just, you know, reading it, I you know, I see this, this little description of what it is, but I don't understand it, I need to talk to someone, well, a great person to start with would be Roman x, I, maybe that's the right pronunciation of this person's name. That's my bad. Sorry, Romain accent, that's not how you pronounce it. But maybe the right person to ask is romaniacs, maybe I can find them on my you know, on slack or these days, make a make a meet, call, make a zoom call. And try to just get an explanation from from that person. And they can hopefully be really helpful to you. The last set of tools I want to talk about are really helpful when you're working with libraries.</p>
<p>29:18<br />
So and</p>
<p>29:20<br />
this, this will happen sometimes, obviously, and ideally, the library has beautiful documentation that just makes it really easy to understand. I think reading documentation and understanding it is kind of its own skill in a way that you'll certainly develop with time. And, but also, sometimes libraries don't have the best documentation. And that's just part of life, unfortunately. So in those cases, you know, I can't believe I've gotten this far in this talk without mentioning StackOverflow. But it's super useful to be able to use Stack Overflow and find other people who are using this library and see exactly how they're doing it and try to find what problems they're running into. There's, there's again, no shame in this like,</p>
<p>30:03<br />
I think for me, this was a little bit</p>
<p>30:06<br />
of something that I had to learn where,</p>
<p>30:08<br />
you know, if I googled the answer to a physics problems that in school, that was bad, that's cheating. But like if I google and figure out how to solve this weird bug that we're running into in production, like I'm</p>
<p>30:19<br />
the hero suddenly, which is amazing.</p>
<p>30:23<br />
Then this was sort of a lightbulb moment for me, is the idea of using GitHub</p>
<p>30:27<br />
search specifically.</p>
<p>30:30<br />
Because there's a ton of publicly available code on GitHub, and they will let you search it all, which is so incredibly powerful. And I don't think I realized how powerful it was, until I had this this realization of like, oh, let me just see what other people are doing on GitHub. Sometimes you won't be able to find a good example on StackOverflow. But you can find a good example on GitHub search. So</p>
<p>30:51<br />
for instance,</p>
<p>30:52<br />
let's say you're working with a library, you don't feel like you're getting as much as you want out of the documentation. And so like, let's say, you're, you're, you know,</p>
<p>31:00<br />
you're using BigQuery.</p>
<p>31:02<br />
And you want to know, what are ways that I can configure a query job in BigQuery, you might take the name of that object,</p>
<p>31:09<br />
and just type it into GitHub search and see what comes back.</p>
<p>31:13<br />
A couple pro tips here.</p>
<p>31:15<br />
First thing, mess around with this sort. This is completely anecdotal, but I have had much better luck. Looking at most recently indexed is one of the options. And that's just like things that had been updated recently, for some reason, I found that that leads me to more useful results generally. On an over on the left here, you'll notice that you can filter down to specific languages. And so if you're using like, Java, you can pick Java, and that will also help you sort of find more specific examples that can be helpful. So, you know, here I've selected Java and most recently, most recently index and and then sort of the next step here would be to Okay, I'm going to look at this free tier billing service and look at this query job configuration builder that they're setting up and understand like, what are the options they're using, because I only was only able to find one example of how to set one of these things up. And now I have another that I can understand better.</p>
<p>32:09<br />
So</p>
<p>32:10<br />
this was kind of</p>
<p>32:13<br />
a lot of things. And so let's, let's sort of recap, everybody. And the big takeaways that I have for you are to Firstly, focus on delivering software,</p>
<p>32:25<br />
I know that</p>
<p>32:26<br />
it is always very challenging to start a new team, it can be really intimidating. And to that end, I think it's important that you focus on trying to get something delivered. And that is useful and helpful. With you know, the optimal amount of haste, whatever that happens to be.</p>
<p>32:47<br />
When you do this,</p>
<p>32:48<br />
you can free yourself from having to, from having to sort of feel like you need to read everything, or understand everything super in depth, because all you need to do is understand the system exactly well enough to make the change that you need to make, all you need to do is understand a certain object enough to know what it's doing, you don't need to know exactly how it's doing everything, you it's completely fine for you to let some things be unknown to you. And under and trust that you will come back and understand those later if you need to. When doing this, it will help you focus your learning on the parts of the code that are going to be most useful to you, the best way to learn something is just by doing it. And this is what you are doing as a software engineer. And so you should focus on doing that. When you are joining a new team, provide value to that team. I think this is something that's very helpful for a number of reasons. So firstly, it's just you know, I mean, that's kind of your job is to help the team, right? software development is a team sport, and you want to make sure that you are pulling your own weight. But it's also kind of even just for selfish reasons, really nice. If you're consistently kind to people and helping people out with things. And if you are making a quick start of it and saying Hey, everyone, I updated the architecture diagram,</p>
<p>34:08<br />
hope this is helpful for you all.</p>
<p>34:10<br />
That's a some some early value that you can share to people and I think that's easier to do than you might realize, and and even selfishly, if you're able to do that you can build goodwill with people and then that will make it easier for you to go to them and say, Hey, I have this question. I like I'm so dumb, but like, Can you explain how this thing works, and they will often be much happier to help you if you've already been helpful to them. Finally, the the main another main thing here is to decrease cognitive load. And in my experience, writing code is one of the most difficult parts of being a software engineer it can be because you're having to sort of work oftentimes at the boundaries of this boundaries have your ability, right up next to the edge of what you feel like you're capable of doing. And so anything you can do to make it easier on</p>
<p>35:06<br />
yourself, not only just like,</p>
<p>35:09<br />
makes it easier, but also helps you be able to achieve more. Because if you can offload some some part of</p>
<p>35:15<br />
that work to some sort of external system</p>
<p>35:18<br />
that can be that can mean that you can then use that extra brain space to achieve something really important. So that involves things like creating diagrams, writing down what you're doing writing down file names, and these can all be super helpful things to do as you develop your software.</p>
<p>35:41<br />
My name is Samuel Taylor. I really have enjoyed getting to talk to you. My Twitter handle is Samuel data T, I would love to chat with you there or feel free to email me.</p>
  </body>
</html>